package cobrayaml

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"strings"
	"text/template"

	"gopkg.in/yaml.v2"
)

// FuncInfo holds information about a function to be generated
type FuncInfo struct {
	Name    string
	Flags   []FlagConfig
	Args    *ArgsConfig
	CmdPath string // e.g., "root > add" for context
}

// GeneratorConfig holds configuration for code generation
type GeneratorConfig struct {
	PackageName string
	OutputPath  string
}

// Generator generates handler function stubs from YAML config
type Generator struct {
	config *ToolConfig
}

// NewGenerator creates a new generator from a YAML file
func NewGenerator(configPath string) (*Generator, error) {
	data, err := os.ReadFile(configPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read config file: %w", err)
	}

	var config ToolConfig
	if err := yaml.Unmarshal(data, &config); err != nil {
		return nil, fmt.Errorf("failed to unmarshal YAML: %w", err)
	}

	return &Generator{config: &config}, nil
}

// NewGeneratorFromString creates a new generator from YAML string
func NewGeneratorFromString(yamlContent string) (*Generator, error) {
	var config ToolConfig
	if err := yaml.Unmarshal([]byte(yamlContent), &config); err != nil {
		return nil, fmt.Errorf("failed to unmarshal YAML: %w", err)
	}

	return &Generator{config: &config}, nil
}

// CollectFunctions collects all function info from the config
func (g *Generator) CollectFunctions() []FuncInfo {
	var funcs []FuncInfo

	// Check root command
	if g.config.Root.RunFunc != "" {
		funcs = append(funcs, FuncInfo{
			Name:    g.config.Root.RunFunc,
			Flags:   g.config.Root.Flags,
			Args:    g.config.Root.Args,
			CmdPath: g.config.Root.Use,
		})
	}

	// Collect from all commands recursively
	for _, cmdConfig := range g.config.Commands {
		funcs = append(funcs, g.collectFromCommand(cmdConfig, "")...)
	}

	return funcs
}

func (g *Generator) collectFromCommand(cmd CommandConfig, parentPath string) []FuncInfo {
	var funcs []FuncInfo

	cmdPath := cmd.Use
	if parentPath != "" {
		cmdPath = parentPath + " > " + cmd.Use
	}

	if cmd.RunFunc != "" {
		// Collect flags including parent persistent flags
		funcs = append(funcs, FuncInfo{
			Name:    cmd.RunFunc,
			Flags:   cmd.Flags,
			Args:    cmd.Args,
			CmdPath: cmdPath,
		})
	}

	// Recurse into subcommands
	for _, subCmd := range cmd.Commands {
		funcs = append(funcs, g.collectFromCommand(subCmd, cmdPath)...)
	}

	return funcs
}

const handlerTemplate = `// Code generated by cobrayaml. DO NOT EDIT.
// You can customize the function bodies below.

package {{.PackageName}}

import (
	"github.com/spf13/cobra"
)

{{range .Functions}}
// {{.Name}} handles the "{{.CmdPath}}" command
func {{.Name}}(cmd *cobra.Command, args []string) error {
{{- if or .Flags .Args}}
	// Auto-generated flag/arg getters
{{- end}}
{{- range .Flags}}
{{- if eq .Type "string"}}
	{{.Name | toCamelCase}}, _ := cmd.Flags().GetString("{{.Name}}")
{{- else if eq .Type "bool"}}
	{{.Name | toCamelCase}}, _ := cmd.Flags().GetBool("{{.Name}}")
{{- else if eq .Type "int"}}
	{{.Name | toCamelCase}}, _ := cmd.Flags().GetInt("{{.Name}}")
{{- else if eq .Type "stringSlice"}}
	{{.Name | toCamelCase}}, _ := cmd.Flags().GetStringSlice("{{.Name}}")
{{- end}}
{{- end}}
{{- if .Args}}
{{- if eq .Args.Type "exact"}}
{{- range $i := iterate .Args.Count}}
	arg{{$i}} := args[{{$i}}]
{{- end}}
{{- else if or (eq .Args.Type "min") (eq .Args.Type "any") (eq .Args.Type "range")}}
	// args contains {{if eq .Args.Type "min"}}at least {{.Args.Min}}{{else if eq .Args.Type "range"}}{{.Args.Min}} to {{.Args.Max}}{{else}}any number of{{end}} argument(s)
{{- end}}
{{- end}}

	// TODO: Implement your logic here
{{- range .Flags}}
	_ = {{.Name | toCamelCase}}
{{- end}}
{{- if .Args}}
{{- if eq .Args.Type "exact"}}
{{- range $i := iterate .Args.Count}}
	_ = arg{{$i}}
{{- end}}
{{- end}}
{{- end}}

	return nil
}
{{end}}
`

// GenerateHandlers generates handler function stubs
func (g *Generator) GenerateHandlers(packageName string) (string, error) {
	funcs := g.CollectFunctions()

	if len(funcs) == 0 {
		return "", fmt.Errorf("no functions to generate (no run_func defined in YAML)")
	}

	funcMap := template.FuncMap{
		"toCamelCase": toCamelCase,
		"iterate":     iterate,
	}

	tmpl, err := template.New("handlers").Funcs(funcMap).Parse(handlerTemplate)
	if err != nil {
		return "", fmt.Errorf("failed to parse template: %w", err)
	}

	data := struct {
		PackageName string
		Functions   []FuncInfo
	}{
		PackageName: packageName,
		Functions:   funcs,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("failed to execute template: %w", err)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted if formatting fails
		return buf.String(), nil
	}

	return string(formatted), nil
}

// GenerateHandlersToFile generates handlers and writes to file
func (g *Generator) GenerateHandlersToFile(packageName, outputPath string) error {
	code, err := g.GenerateHandlers(packageName)
	if err != nil {
		return err
	}

	return os.WriteFile(outputPath, []byte(code), 0644)
}

// toCamelCase converts kebab-case or snake_case to camelCase
func toCamelCase(s string) string {
	s = strings.ReplaceAll(s, "-", "_")
	parts := strings.Split(s, "_")

	for i := 1; i < len(parts); i++ {
		if len(parts[i]) > 0 {
			parts[i] = strings.ToUpper(parts[i][:1]) + parts[i][1:]
		}
	}

	result := strings.Join(parts, "")
	// Ensure first character is lowercase
	if len(result) > 0 {
		result = strings.ToLower(result[:1]) + result[1:]
	}
	return result
}

// iterate returns a slice of integers from 0 to n-1
func iterate(n int) []int {
	result := make([]int, n)
	for i := range n {
		result[i] = i
	}
	return result
}

const mainTemplate = `// Code generated by cobrayaml. DO NOT EDIT.

package {{.PackageName}}

import (
	"os"

	"github.com/S-mishina/cobrayaml"
)

func main() {
	builder, err := cobrayaml.NewCommandBuilder("{{.ConfigPath}}")
	if err != nil {
		panic(err)
	}

{{range .Functions}}	builder.RegisterFunction("{{.Name}}", {{.Name}})
{{end}}
	rootCmd, err := builder.BuildRootCommand()
	if err != nil {
		panic(err)
	}

	if err := rootCmd.Execute(); err != nil {
		os.Exit(1)
	}
}
`

// GenerateMain generates main.go that wires up the CLI
func (g *Generator) GenerateMain(packageName, configPath string) (string, error) {
	funcs := g.CollectFunctions()

	tmpl, err := template.New("main").Parse(mainTemplate)
	if err != nil {
		return "", fmt.Errorf("failed to parse main template: %w", err)
	}

	data := struct {
		PackageName string
		ConfigPath  string
		Functions   []FuncInfo
	}{
		PackageName: packageName,
		ConfigPath:  configPath,
		Functions:   funcs,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("failed to execute main template: %w", err)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted if formatting fails
		return buf.String(), nil
	}

	return string(formatted), nil
}

// GenerateMainToFile generates main.go and writes to file
func (g *Generator) GenerateMainToFile(packageName, configPath, outputPath string) error {
	code, err := g.GenerateMain(packageName, configPath)
	if err != nil {
		return err
	}

	return os.WriteFile(outputPath, []byte(code), 0644)
}
